{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Domestic Tariff Scheduler SDK","text":"<p>The Domestic Tariff Scheduler SDK is designed to help users easily leverage pricing data provided by Energy Suppliers. It enables smart actions on connected devices when prices are particularly low or high, simplifying the process of optimizing energy usage.</p> <p>By handling the complexities of API integration, validation, and near-optimal usage, the SDK eliminates much of the usual hassle. You simply define your desired actions, configure your preferences, and let the SDK handle the rest.</p> <p>For convenience, we recommend running the SDK on a Raspberry Pi, as it typically comes pre-installed with Python. This allows you to quickly install the SDK and start automating your energy-related actions.</p> <p>Recognizing that users may have diverse configuration needs, the SDK is designed to be highly customizable. You can define how prices are selected, specify how pricing data is used, and integrate the SDK with any actions or devices you choose\u2014all while maintaining flexibility and control.</p>"},{"location":"#what-are-tariffs","title":"What are tariffs","text":"<p>Tariffs are what Energy Suppliers use to offer pricing options for your electricity usage, these vary between suppliers are specialised to what type of customer you are, such as the Octopus Agile Tariff is set up in a way for people who are concious of the changes in prices throughout the day, allowing them to plan around these.</p>"},{"location":"#do-prices-even-change-that-much","title":"Do prices even change that much?","text":"<p>Yes they do, the prices are driven by supply and demand throughout the day, such as when people are awake or asleep, or fluctuations in generation such as it being windy during the day leading to cheaper electricity from renewable sources.</p> <p>Here's an example of 11 days and a schedule generated from this SDK for Octopus Agile tariff, for a battery being charged under constant load:</p> <p></p> <p>Source: Linkedin - Craig White</p>"},{"location":"#current-supported-supplier-tariffs","title":"Current supported supplier tariffs","text":"<ul> <li>Octopus Agile Tariff</li> </ul>"},{"location":"#prospective-supplier-tariffs","title":"Prospective supplier tariffs","text":"<ul> <li>Octopus Go (EV Tariff)</li> <li>Octopus Tracker</li> <li>E.ON Next Flex</li> </ul>"},{"location":"#example-usage","title":"Example usage","text":"<p>If you want to be featured on here send me a message on linkedin and I'll get it listed here :)</p> <ul> <li>battery.craigwh.it: Raspberry Pi4b using smart scheduling to do battery arbitrage to keep a server online</li> </ul>"},{"location":"#related-links","title":"Related links","text":"<ul> <li>https://github.com/craigwh10/domestic-tariff-scheduler-sdk</li> </ul>"},{"location":"getting-started/custom-prices-to-include/","title":"Using custom price_to_include functions","text":"<p>As touched on in running first schedule page, this introduces the <code>number_to_include</code> configuration parameter, mentioning that it can either be a positive integer value or a custom function, this is going to show you how to use this method to select prices programattically.</p> <p>The function must always return an integer otherwise it will fail, this integer is the number of prices the pricing strategy will act on.</p>"},{"location":"getting-started/custom-prices-to-include/#example","title":"Example","text":"<pre><code># main.py\nfrom domestic_tariff_scheduler_sdk import tariff, Price\n\ndef action_when_cheap(price: Price):\n    print(\"cheap\", price.value)\n\ndef action_when_expensive(price: Price)\n    print(\"expensive\", price.value)\n\ndef prices_to_include(prices: list[Price]):\n    # only get the count where sum cost is no greater than 15p/kWh\n    # i.e 3.0 + 5.0 + 3.0 + 4.0 = 15 (wont include 8.0)\n\n    total = 0\n    count = 0\n    sorted_prices = sorted(prices, key=lambda obj: min(obj.value, obj.value))\n    for price in sorted_prices:\n        total += price.value\n        count += 1\n        if total &gt;= 15:\n            break \n\n    return count\n\n\ntariff.run_octopus_agile_tariff_schedule(\n        prices_to_include: prices_to_include,\n        action_when_cheap: action_when_cheap,\n        action_when_expensive: action_when_expensive,\n)\n</code></pre> <p>In this setup I've created a theoretical scenario where I only want to spend take advantage of 15p/kWh total of prices, and work out from the available prices how many prices that is, which the strategy will then use.</p>"},{"location":"getting-started/custom-pricing-strategies/","title":"Using custom pricing strategies","text":"<p>By default the scheduler will simply just rank the prices and assign them to the appropriate actions, but you might hit a case where you need something more complex than that, such as if you have a system where constraints are important or if you wanted to introduce another parameter to the scheduling, such as carbon intensity.</p>"},{"location":"getting-started/custom-pricing-strategies/#what-are-these","title":"What are these?","text":"<p>Custom pricing strategies are python classes that you define and pass into the method for the appropriate tariff, in these you can write your own functionality that acts on the prices, this is using a Strategy pattern which injects in the config in runtime so that you can use the values you addtionally passed in.</p> <p>For a description of the configuration you can pass in see configuration.</p>"},{"location":"getting-started/custom-pricing-strategies/#example-creating-a-custom-pricing-strategy","title":"Example: creating a custom pricing strategy","text":"<p>Here I'm going to set up a custom pricing strategy which makes sure:</p> <ul> <li>I don't ever spend more than 10p/kWh</li> <li>I only ever switch on my device if carbon intensity is below 100 units</li> </ul> <p>Additionally I'm going to set up some custom actions which:</p> <ul> <li>Send a text message to my phone telling me that my smart plug is being switched on (done via AWS SNS)</li> <li>Send a HTTP RPC request to my shelly on the same WIFI network to start and stop when this conditions are met</li> </ul> <p>It's important to note that in this example, that the custom pricing strategy <code>CustomPricingStrategy</code> inherits from <code>PricingStrategy</code>, this is necessary otherwise you will hit a validation error to ensure it meets the contract and works with the rest of the code.</p> <pre><code>from domestic_tariff_scheduler_sdk import tariff, Price, PricingStrategy, ScheduleConfig\n\nclass CustomPricingStrategy(PricingStrategy):\n    def __init__(self, config: ScheduleConfig):\n        self.config = config # for access to other set configuration\n\n    def _get_carbon_intensity(self, price: Price):\n        res = requests.get(f\"https://api.carbonintensity.org.uk/intensity/{price.datetime_from}\")\n        return res.json()[\"data\"][0][\"intensity\"][\"actual\"]\n\n    def handle_price(self, price: Price, prices: list[Price]):\n        if price.value &lt; 10 and self._get_carbon_intensity(price) &lt; 100:\n            self.config.action_when_cheap(price)\n        else:\n            self.config.action_when_expensive(price)\n\ndef switch_shelly_on_and_alert(price: Price):\n    time = price.datetime_from.strftime(\"%H:%M\")\n    logging.info(f\"Time: {time}, Action: action_when_cheap, Price: {price.value}p/kWh\")\n    SMS.send(f\"Price is cheap ({price}p/kWh), turning on shelly\")\n    requests.get(\"http://&lt;shelly_ip&gt;/relay/0?turn=on\")\n\ndef switch_shelly_off_and_alert(price: Price):\n    time = price.datetime_from.strftime(\"%H:%M\")\n    logging.info(f\"Time: {time}, Action: action_when_cheap, Price: {price.value}p/kWh\")\n    SMS.send(f\"Price is expensive ({price}p/kWh), turning off shelly\")    \n    requests.get(\"http://&lt;shelly_ip&gt;/relay/0?turn=off\")\n\nsdk.run_octopus_agile_tariff_schedule(\n    prices_to_include=5, # 5 opportunties to trigger \"action_when_cheap\"\n    action_when_cheap=switch_shelly_on_and_alert,\n    action_when_expensive=switch_shelly_off_and_alert,\n    pricing_strategy=CustomPricingStrategy\n)\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>First check that you have python installed on your machine:</p> <pre><code>python --version\n</code></pre> <p>If you do not then follow this guide or use your preferred manager such as homebrew.</p> <p>Given now you have python installed, use the following command to install the dependency on your machine (or in a virtual environment).</p> <pre><code>pip install domestic-tariff-scheduler-sdk\n</code></pre>"},{"location":"getting-started/running-first-schedule/","title":"Running your first schedule","text":""},{"location":"getting-started/running-first-schedule/#configuration","title":"Configuration","text":"<ul> <li><code>prices_to_include</code> is the number of the cheapest half hourly periods that you want to include</li> <li>this can be a function (as defined in custom prices to include)</li> <li>or simply just an integer value between <code>0</code> and <code>46</code> ( a full day 0:00-23:00)</li> <li><code>action_when_cheap</code> is your function that is called when the half hourly period is among the cheapest</li> <li><code>action_when_expensive</code> is your function that is called when the half hourly period is more expensive than the cheapest</li> <li><code>pricing_strategy</code> is a custom class you can pass in to act on prices in a more complex way (this is covered in custom pricing strategies)</li> </ul>"},{"location":"getting-started/running-first-schedule/#setting-up-actions","title":"Setting up actions","text":"<p>In the SDK we have two available methods that you need to set, <code>action_when_cheap</code> and <code>action_when_expensive</code>, see below a simple example of how this is set up.</p> <pre><code># main.py\nfrom domestic_tariff_scheduler_sdk import tariff, Price\n\ndef action_when_cheap(price: Price):\n    print(\"cheap\", price.value)\n\ndef action_when_expensive(price: Price)\n    print(\"expensive\", price.value)\n\ntariff.run_octopus_agile_tariff_schedule(\n  prices_to_include: 12,\n  action_when_cheap: action_when_cheap,\n  action_when_expensive: action_when_expensive,\n)\n</code></pre> <p>You can see here in this example that there are two function I have created, one that runs when the prices are cheap, which in this case will run a simple print in the 12 cheapest half hourly prices of the day and will run a simple print in the expensive other 44 periods of the day.</p> <p>You can change these methods to do whatever you like, a common example is using a smart plug HTTP API's to make them turn on and off during those periods.</p> <p>If you now run your script it will stay running and you should see in your logs which periods it is running and with what time like below.</p> <pre><code>$ python main.py\nINFO Generating schedule for 46 prices\nINFO Time: 00:00, Action: action_when_cheap, Price: 4p/kWh\nINFO Time: 00:30, Action: action_when_cheap, Price: 8p/kWh\nINFO Time: 01:00, Action: action_when_cheap, Price: 18p/kWh\nINFO Time: 01:30, Action: action_when_cheap, Price: 12p/kWh\nINFO Time: 02:00, Action: action_when_expensive, Price: 50p/kWh\n...\nINFO Schedule generated, waiting for jobs to run... \n</code></pre> <p>Please note that if you have a custom pricing strategy that the logs wont automatically show, you have to add them yourself as shown in custom pricing strategy example.</p>"}]}